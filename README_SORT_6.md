Анализ алгоритмов сортировки
-
Сортировка Шелла (Shell Sort)
-
Концепция: Усовершенствованная версия сортировки вставками, использующая переменный интервал для сравнения элементов.

Механизм работы:

Использует последовательность интервалов, начиная с большого и уменьшая до 1
На каждом интервале выполняет сортировку вставками элементов, отстоящих друг от друга на заданное расстояние
По мере уменьшения интервала массив становится более упорядоченным
Ключевые циклы:

gap = n // 2
while gap > 0:
    for i in range(gap, n):
        temp = arr[i]
        j = i
        while j >= gap and arr[j - gap] > temp:
            arr[j] = arr[j - gap]
            j -= gap
        arr[j] = temp
    gap //= 2
    
Эффективность Зависит от выбора последовательности интервалов
Худший случай: O(n²) при неудачной последовательности
Лучшие последовательности: могут достигать O(n log²n)

Сортировка слиянием (Merge Sort)
-
Стратегия: Алгоритм "разделяй и властвуй", рекурсивно делящий массив и объединяющий отсортированные части.

Основные этапы:

Разделение:

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]
        merge_sort(left)
        merge_sort(right)
        
Слияние:

i = j = k = 0
while i < len(left) and j < len(right):
    if left[i] < right[j]:
        arr[k] = left[i]
        i += 1
    else:
        arr[k] = right[j]
        j += 1
    k += 1
    
Производительность:

Сложность: O(n log n) во всех случаях
Память: O(n) дополнительной памяти
Стабильность: Да

Быстрая сортировка (Quick Sort)
-
Подход: Эффективный алгоритм с выбором опорного элемента и разделением массива.

Процесс выполнения:

Разделение:

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
    
Рекурсивная сортировка:

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)
        
Эффективность: O(n log n)
Память: O(log n) для стека вызовов
Сортировка выбором (Selection Sort)

Принцип: Поиск минимального элемента в неотсортированной части и обмен с первым элементом этой части.

Алгоритм:

python
for i in range(len(arr)):
    min_idx = i
    for j in range(i + 1, len(arr)):
        if arr[j] < arr[min_idx]:
            min_idx = j
    arr[i], arr[min_idx] = arr[min_idx], arr[i]
Характеристики:

Сложность: O(n²) во всех случаях
Память: O(1)
Нестабильность: Может менять порядок одинаковых элементов

Сортировка вставками (Insertion Sort)
-
Метод: Построение отсортированной последовательности путем вставки элементов в правильную позицию.

Реализация:

python
for i in range(1, len(arr)):
    key = arr[i]
    j = i - 1
    while j >= 0 and arr[j] > key:
        arr[j + 1] = arr[j]
        j -= 1
    arr[j + 1] = key
Свойства:

Лучший случай: O(n) для почти отсортированных массивов
Стабильность: Да
